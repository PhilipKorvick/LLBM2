# LLBM2
A light board fun project for my kids

Design Overview
This project uses an ATmega32U4 microprocessor to control seven RGB LEDs and fifteen backlit buttons to produce a fun interactive gadget for my kids. The RGB LEDs are Pulse Width Modulation (PWM) driven, where the back lights for the buttons are only on or off due to processing power. Due to the limitations on the number of outputs on the microprocessor shift registers were used to expand the I/O capabilities. 
## Hardware Design
### Power
Due to the device being a toy, a battery was chosen as the power source since the idea was to be hand held and mobile. The power circuit is made up of a standard nine volt (9v) battery, and five volt power efficient regulator which is delivered directly to the microprocessor board. The extra voltage regulator is used because the voltage regulator on the microprocessor board that was chosen could not regulate nine volts input power. The 5 volt power rail was also used to connect to the power input of the shift registers.
### Input and Output
There are two different types of outputs and one type of input on the device. The first kind of output are the RGB LEDs with independent PWM brightness control. The second type of output are the back lights for the buttons which can independently be turned on and off. The inputs for this device are normally open buttons. Each of these circuits are described below.
The output RGB LES circuit starts with three shift registers which are responsible for each of the different colors. These shift registers are capable of driving the current for the connected LED. The outputs are connected to current limiting resistors that were selected for each of the different color LEDs due to differences in turn on voltage. The circuit then connects to the respective LED anode. The RGB LEDs used in this project are common cathode, so one connection to the zero volts line of the circuit. There are small capacitors connected between the outputs of the shift register and ground to protect the circuit during PWM operation.
The back lights for the buttons start with the output form a set of two shift registers, each with eight output pins. Due to the fact that the back lights are designed to work between five and twenty four volts, no other hardware is needed for this circuit and the back light LED is connected between the output of the of the shift register and the zero volts line. This results in a dim back light so more voltage may need to be applied to these buttons if the full brightness is to be driven.
The inputs on the device are normally open momentary buttons. These buttons are connected to the five volt rail on one side and pull down resistors on the other. The pull down resistors are then directly connected to the zero volts line. The input shift register is connected to the mesh between the button and the pull down resistor. This allows a high voltage reading to represent a pressed button and a low voltage reading to represent a not pressed button. This also for the circuit to be more power efficient because the button is not designed to be pressed for a long time and the resistor is relatively large which reduces the power consumed by a button press.
### Logical
The ATmega’s GPIO pins were connected to the shift registers in such a way to optimize the number of shift registers that could be connected. All of the shift registers in the project are eight bits and used the same architecture of using a clock, polling, and suppression signals. There are different clock and polling outputs for the input and output shift registers because the output shift registers operate much faster than the input registers due to the PWM operation. The rest of the connections are data lines connecting the serial input/output data to the shift registers to be parallelized. Each of these connections is connected with a pull down resistor for proper operation. 
## Software Design
There are three main components used in the software design; the output abstraction and real time interrupt, the input abstraction and the behavior functions. The input and output abstraction are used to produce a simple interface to the I/O points for the behavior functions to interact with. The behavior functions control how the device works and are selectable through a menu function. 
The output abstraction is designed to control the backlight LEDs and the PWM RGB LEDs on the device. The interface between the abstraction layer is an array of LED pulse width lengths which represent the brightness of each of the LEDs. A value of zero and below represent an off state where one through thirty one represent the brightness of a given led. These values are used by the output abstraction to calculate when to turn each LED on or off in the PWM cycle. Each of the PWM cycles is divided up into thirty two frames. During each frame the interface value of the LED pulse width is compared to a frame counter and if the frame counter is less than or equal to the LED pulse width the LED is set to on, otherwise it is set to off. This process is broken up into eight loops which represent the eight serial bits shifted into the output shift registers. Note that the clock single is toggled on and off again for each loop. Once the frame is complete, the frame counter is incremented and the polling signal is toggled on and off again to move the serial data in the shift register into the output parallel pins. At the end of the PWM cycle, when the frame counter gets greater or equal to thirty two, the frame counter is reset to zero at the beginning of that frame. Due to the real time nature of PWM, a real time interrupt was implemented to stabilize the time between PWM frames. The onboard real time clock accumulates a counter and regularly initializes the PWM frame calculation so that the PWM looks good.
The Input Abstraction is designed to make it easy to receive the state of the buttons on the device. This is accomplished by using an interface between the abstraction layer is an array of variables that represent each of the current states of the respective button and an array containing the previous state or echo of the button’s state when the button was polled. The echo is used to create one shot function calls on either the rising side or the falling side of the button press. The process of reading the buttons starts with the clock suppression line being set to high. Then the pole device line is toggled off then on again which moves the current state of each of the input lines into the input shift register. The clock suppression line is then set to low again. Finally as the clock line is toggled on and off again, the serial data is pushed down the data line and read by the microprocessor. At the beginning of the input cycle the button data that was read in the previous pass is placed into the respective button echo values and the data that was just read in is placed into the current button values.
The behavior functions are used to establish how the user interacts with the device. The base of the behavior functions is the menu. At startup or if the user presses the four corner buttons at the same time, the behavior functions will switch to the menu state. In the menu state other functions will be presented to the user through buttons that are illuminated. Each of these buttons has been assigned a value and that value is used when a button is pressed to select the next behavior in a switch statement. Currently I have made five different behavior functions, so the top five buttons are illuminated in the menu function. The other behavior functions are simple and designed to be interactive experiences for the user.
## Project Contents
The contents of this project currently are the following:
- .ino code file used by the Arduino compiler to burn the code to the microprocessor
- Gerber files of a breakout board for the shift registers. Note that for the output shift registers capacitors were placed between the output and ground to protect the device and on the input shift registers these spaces were used to put the pull down resistors.
